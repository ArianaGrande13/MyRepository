## 1. 基础api
在 Drools 当中，规则的编译与运行要通过Drools 提供的各种API 来实现，这些API 总体来讲可以分为三类：规则编译、规则收集和规则的执行。完成这些工作的API 主要有KnowledgeBuilder、KnowledgeBase、StatefulKnowledgeSession、StatelessKnowledgeSession、、等，它们起到了对规则文件进行收集、编译、查错、插入fact、设置global、执行规则或规则流等作用

### 1.1 KnowledgeBuilder
KnowledgeBuilder 在业务代码当中收集已经编写好的规则， 然后对这些规则文件进行编译， 最终产生一批编译好的规则包（KnowledgePackage）给其它的应用程序使用。KnowledgeBuilder 在编译规则的时候可以通过其提供的hasErrors()方法得到编译规则过程中发现规则是否有错误，如果有的话通过其提供的getErrors()方法将错误打印出来，以帮助我们找到规则当中的错误信息。

### 1.2 KnowledgeBase
KnowledgeBase 是 Drools 提供的用来收集应用当中知识（knowledge）定义的知识库对象，在一个KnowledgeBase 当中可以包含普通的规则（rule）、规则流(rule flow)、函数定义(function)、用户自定义对象（type model）等。KnowledgeBase 本身不包含任何业务数据对象（fact 对象，后面有相应章节着重介绍fact 对象），业务对象都是插入到由KnowledgeBase产生的两种类型的session 对象当中（StatefulKnowledgeSession 和StatelessKnowledgeSession，后面会有对应的章节对这两种类型的对象进行介绍），通过session 对象可以触发规则执行或开始一个规则流执行。

### 1.3. StatefulKnowledgeSessions
StatefulKnowledgeSession 对象是一种最常用的与规则引擎进行交互的方式，它可以与规则引擎建立一个持续的交互通道，在推理计算的过程当中可能会多次触发同一数据集。在用户的代码当中，最后使用完StatefulKnowledgeSession 对象之后，一定要调用其dispose()方法以释放相关内存资源。

### 1.4. StateLessKnowledgeSession
StatelessKnowledgeSession 的作用与StatefulKnowledgeSession 相仿，它们都是用来接收业务数据、执行规则的。事实上，StatelessKnowledgeSession 对StatefulKnowledgeSession 做了包装，使得在使用StatelessKnowledgeSession 对象时不需要再调用dispose()方法释放内存资源了。
在drools 6.x以后这些API 都整合到kie API 中了

## 2. FACT对象
Fact 是指在Drools 规则应用当中，将一个普通的JavaBean 插入到规则的WorkingMemory当中后的对象。规则可以对Fact 对象进行任意的读写操作，当一个JavaBean 插入到WorkingMemory 当中变成Fact 之后，Fact 对象不是对原来的JavaBean 对象进行Clon，而是原来JavaBean 对象的引用。

## 3.语法规则

3.1规则文件
在 Drools 当中，一个标准的规则文件就是一个以“.drl”结尾的文本文件，由于它是一个标准的文本文件，所以可以通过一些记事本工具对其进行打开、查看和编辑。

规则是放在规则文件当中的，一个规则文件可以存放多个规则，除此之外，在规则文件当中还可以存放用户自定义的函数、数据对象及自定义查询等相关在规则当中可能会用到的一些对象。常用的有：package package-name、imports、globals、functions、queries、rules

对于一个规则文件而言，首先声明package 是必须的，除package 之外，其它对象在规则文件中的顺序是任意的，也就是说在规则文件当中必须要有一个package 声明，同时package 声明必须要放在规则文件的第一行。在Drools 的规则文件当中package 对于规则文件中规则的管理只限于逻辑上的管理，，而不管其在物理上的位置如何，这点是规则与Java 文件的package 的区别。对于同一package 下的用户自定义函数、自定义的查询等，不管这些函数与查询是否在同一个规则文件里面，在规则里面是可以直接使用的，这点和Java 的同一package 里的Java类调用是一样的。

### 3.2 规则语言
```
rule "name"
attributes
    when
        LHS
    Then
        RHS
end
```

一个规则通常包括三个部分：属性部分（attribute）、条件部分（LHS）和结果部分（RHS）。对于一个完整的规则来说，这三个部分都是可选的，也就是说如下 所示的规则是合法的：
```
rule "name"
when
then
end
```
### 3.3 条件部分
条件部分又被称之为Left Hand Side，简称为LHS，下文当中，如果没有特别指出，那么所说的LHS 均指规则的条件部分，在一个规则当中when 与then 中间的部分就是LHS 部分。在LHS 当中，可以包含0~n 个条件，如果LHS 部分没空的话，那么引擎会自动添加一个eval(true)的条件，由于该条件总是返回true，所以LHS 为空的规则总是返回true。LHS 部分是由一个或多个条件组成，条件又称之为pattern（匹配模式），多个pattern之间用可以使用and 或or 来进行连接，同时还可以使用小括号来确定pattern 的优先级。 
一个pattern 的语法如下：
```
[绑定变量名:]Object([field 约束])
```
对于一个pattern 来说“绑定变量名”是可选的，如果在当前规则的LHS 部分的其它的pattern 要用到这个对象，那么可以通过为该对象设定一个绑定变量名来实现对其引用，对于绑定变量的命名，通常的作法是为其添加一个“$”符号作为前缀，这样可以很好的与Fact的属性区别开来；绑定变量不仅可以用在对象上，也可以用在对象的属性上面，命名方法与对象的命名方法相同；“field 约束”是指当前对象里相关字段的条件限制，示例如下：
```
rule "rule1"
when
$customer:Customer(age>20,gender==’male’)
Order(customer==$customer,price>1000)
then
<action>…
End
```

此段规则的含义为：的规则就包含两个pattern，第一个pattern 有三个约束，分别是：对象类型必须是Cutomer；同时Cutomer 的age 要大于20 且gender 要是male；第二个pattern 也有三个约束，分别是：对象类型必须是Order，同时Order 对应的Cutomer 必须是前面的那个Customer 且当前这个Order 的price 要大于1000。在这两个pattern 没有符号连接，在Drools当中在pattern 中没有连接符号，那么就用and 来作为默认连接，所以在该规则的LHS 部分中两个pattern 只有都满足了才会返回true。默认情况下，每行可以用“;”来作为结束符（和Java 的结束一样），当然行尾也可以不加“;”结尾。

### 3.3.1约束连接
对于对象内部的多个约束的连接，可以采用“&&”（and）、“||”(or)和“,”(and)来实现，“&&”（and）、“||”(or)和“,”这三个连接符号如果没有用小括号来显示的定义优先级的话，那么它们的执行顺序是：“&&”（and）、“||”(or)和“,” “&&”优先级最高，表面上看“,”与“&&”具有相同的含义，但是有一点需要注意，“，”与“&&”和“||”不能混合使用，也就是说在有“&&”或“||”出现的LHS 当中，是不可以有“，”连接符出 
现的，反之亦然。

#### 3.3.2